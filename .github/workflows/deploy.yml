name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-northeast-1
  TERRAFORM_VERSION: 1.9.0

# Prevent concurrent deployments
concurrency:
  group: streamcaster-deployment
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy StreamCaster
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        
    - name: Terraform Init
      working-directory: terraform
      run: |
        # Remove potentially corrupted state cache
        rm -rf .terraform
        terraform init -reconfigure -lock-timeout=300s
      
    - name: Terraform Validate
      working-directory: terraform
      run: terraform validate
      
    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -detailed-exitcode -lock-timeout=300s
      id: plan
      continue-on-error: true
      
    - name: Check if deployment needed
      id: deploy_check
      run: |
        # Check for infrastructure changes
        INFRA_CHANGES=false
        if [ "${{ steps.plan.outputs.exitcode }}" = "2" ]; then
          INFRA_CHANGES=true
          echo "Infrastructure changes detected"
        fi
        
        # Check for application changes that require redeployment
        APP_CHANGES=false
        if git diff --name-only HEAD~1 HEAD | grep -E "(scripts/|controller/|config/|docker|\.env)" > /dev/null; then
          APP_CHANGES=true
          echo "Application changes detected:"
          git diff --name-only HEAD~1 HEAD | grep -E "(scripts/|controller/|config/|docker|\.env)"
        fi
        
        # Force deploy option
        FORCE_DEPLOY=false
        if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          FORCE_DEPLOY=true
          echo "Force deploy requested"
        fi
        
        # Determine if deployment is needed
        if [ "$INFRA_CHANGES" = "true" ] || [ "$APP_CHANGES" = "true" ] || [ "$FORCE_DEPLOY" = "true" ]; then
          echo "deploy_needed=true" >> $GITHUB_OUTPUT
          echo "Deployment needed: Infrastructure=$INFRA_CHANGES, Application=$APP_CHANGES, Force=$FORCE_DEPLOY"
        else
          echo "deploy_needed=false" >> $GITHUB_OUTPUT
          echo "No deployment needed: No infrastructure or application changes"
        fi
        
    - name: Terraform Apply
      if: steps.deploy_check.outputs.deploy_needed == 'true'
      working-directory: terraform
      run: terraform apply -auto-approve -lock-timeout=300s
      
    - name: Get instance information
      if: steps.deploy_check.outputs.deploy_needed == 'true'
      working-directory: terraform
      run: |
        echo "Instance deployed successfully!"
        terraform output
        
    - name: Wait for instance to be ready
      if: steps.deploy_check.outputs.deploy_needed == 'true'
      run: |
        INSTANCE_IP=$(cd terraform && terraform output -raw static_ip_address)
        echo "Waiting for instance $INSTANCE_IP to be ready..."
        
        # Wait up to 10 minutes for the application to be ready
        timeout 600 bash -c '
          while true; do
            if curl -f -s http://'$INSTANCE_IP':8080/api/health >/dev/null 2>&1; then
              echo "Instance is ready!"
              break
            fi
            echo "Waiting for instance to be ready..."
            sleep 30
          done
        '
        
    - name: Verify deployment
      if: steps.deploy_check.outputs.deploy_needed == 'true'
      run: |
        INSTANCE_IP=$(cd terraform && terraform output -raw static_ip_address)
        echo "Verifying deployment at $INSTANCE_IP..."
        
        # Test API health
        if curl -f http://$INSTANCE_IP:8080/api/health; then
          echo "âœ… API health check passed"
        else
          echo "âŒ API health check failed"
          exit 1
        fi
        
        # Test RTMP stats
        if curl -f http://$INSTANCE_IP:8081/stat >/dev/null 2>&1; then
          echo "âœ… RTMP stats accessible"
        else
          echo "âŒ RTMP stats not accessible"
          exit 1
        fi
        
        echo "ğŸ‰ Deployment verification completed successfully!"
        echo "ğŸŒ Web UI: http://$INSTANCE_IP:8080"
        echo "ğŸ“Š RTMP Stats: http://$INSTANCE_IP:8081/stat"
        echo "ğŸ“º RTMP URL: rtmp://$INSTANCE_IP:1935/live/stream"
        
    - name: Trigger auto-update on existing instance
      if: steps.deploy_check.outputs.deploy_needed == 'false'
      run: |
        INSTANCE_IP=$(cd terraform && terraform output -raw static_ip_address)
        echo "No infrastructure changes, triggering auto-update on existing instance..."
        
        # The auto-update script on the server will detect the new commits
        # and automatically update the application
        echo "Auto-update will be triggered by the cron job within 10 minutes."
        echo "Current instance: http://$INSTANCE_IP:8080"

  notify:
    name: Notify deployment status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy.result == 'success'
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        
    - name: Notify failure
      if: needs.deploy.result == 'failure'
      run: |
        echo "âŒ Deployment failed!"
        exit 1